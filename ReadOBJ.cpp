
#include "stdafx.h"
#include "readobj.h"

//#define T(x) (model->triangles[(x)])

CReadObj::CReadObj()
{
	m_Model = NULL;

	m_TriangleIndexA = NULL;
	m_TriangleIndexB = NULL;
	m_TriangleIndexC = NULL;
}

CReadObj::~CReadObj()
{
	glmDelete(m_Model);
	
	if(m_TriangleIndexA != NULL)
		delete m_TriangleIndexA;
	
	if(m_TriangleIndexB != NULL)
		delete m_TriangleIndexB;
	
	if(m_TriangleIndexC != NULL)
		delete m_TriangleIndexC;
}

bool CReadObj::Load(LPCTSTR  strFileName)
{
    //first ,clean the previous memory 
	if(m_Model!=NULL)
	{
		if(m_Model->facetnorms!=NULL)
			free(m_Model->facetnorms);
		if(m_Model->groups!=NULL)
			free(m_Model->groups);
		if(m_Model->materials!=NULL)
			free(m_Model->materials);
		if(m_Model->normals!=NULL)
			free(m_Model->normals);
		if(m_Model->texcoords!=NULL)
			free(m_Model->texcoords);
		if(m_Model->triangles!=NULL)
			free(m_Model->triangles);
		if(m_Model->vertices!=NULL)
			free(m_Model->vertices);
	}

	//read obj file:
	m_Model = glmReadOBJ((char *)strFileName);
	if(m_Model==NULL)
		return FALSE;

	glmUnitize(m_Model);
	glmFacetNormals(m_Model);
	glmVertexNormals(m_Model, 90);

	//
	//write trangles:

	static GLMgroup* group=NULL;
	static GLMtriangle* triangle=NULL;

	int nTriangleNum = m_Model->numtriangles;
	m_TriangleIndexA = new int[nTriangleNum];
	m_TriangleIndexB = new int[nTriangleNum];
	m_TriangleIndexC = new int[nTriangleNum];

	int t1,t2,t3;
	group = m_Model->groups;
	int index = 0;
	while (group)
	{	
		for (GLuint i = 0; i < group->numtriangles; i++) 
		{
			triangle = &m_Model->triangles[ (group->triangles[i]) ];
			t1=3*triangle->vindices[0]/3-1;
			t2=3*triangle->vindices[1]/3-1;
			t3=3*triangle->vindices[2]/3-1;
		
			m_TriangleIndexA[index] = t1;
			m_TriangleIndexB[index] = t2;
			m_TriangleIndexC[index] = t3;

			index++;
		}
		group = group->next;
	}

	return TRUE;
}

bool CReadObj::Render()
{

	if(m_Model!=NULL)
	{
		glmDraw(m_Model, GLM_SMOOTH | GLM_COLOR);
		return TRUE;
	}
	else
		return FALSE;
}

void CReadObj::GetMaxMin(float &xMin,float &xMax,
				   float &yMin,float &yMax,
				   float &zMin,float &zMax)
{
	xMin=0;
	yMin=0;
	zMin=0;
	xMax=0;
	yMax=0;
	zMax=0;

	int nVertex=m_Model->numvertices;

	for(int i=1;i<nVertex+1;i++)
	{
		
		if(xMin>m_Model->vertices[3*i])
			xMin=m_Model->vertices[3*i];
		if(xMax<m_Model->vertices[3*i])
			xMax=m_Model->vertices[3*i];

		if(yMin>m_Model->vertices[3*i+1])
			yMin=m_Model->vertices[3*i+1];
		if(yMax<m_Model->vertices[3*i+1])
			yMax=m_Model->vertices[3*i+1];

		if(zMin>m_Model->vertices[3*i+2])
			zMin=m_Model->vertices[3*i+2];
		if(zMax<m_Model->vertices[3*i+2])
			zMax=m_Model->vertices[3*i+2];
	}	
}

bool CReadObj::SaveAsPLY(LPCTSTR strFileName)
{	
	if(m_Model != NULL)
	{	
		static GLuint i=0;
		static GLMgroup* group=NULL;
		static GLMtriangle* triangle=NULL;
		
		
		ASSERT(m_Model);
		ASSERT(m_Model->vertices);
		
		group=m_Model->groups;
		
		FILE *fp=fopen(strFileName,"w");
		if(fp==NULL) return FALSE;
		
		fprintf(fp,"ply\n");
		fprintf(fp,"format ascii 1.0\ncomment generated by xdh\n");
		
		fprintf(fp,"element vertex %d \n",m_Model->numvertices);
		fprintf(fp,"property float x\n");
		fprintf(fp,"property float y\n");
		fprintf(fp,"property float z\n");
		
		fprintf(fp,"element face %d\n",m_Model->numtriangles);
		
		fprintf(fp,"property list uchar int vertex_indices\n");
		fprintf(fp,"end_header\n");
		
		//write vertices:
		//fprintf(fp,"0 0 0\n");
		for (i=1; i<=m_Model->numvertices; i++)
		{
			fprintf(fp,"%f %f %f\n",m_Model->vertices[3*i],
				m_Model->vertices[3*i+1],
				m_Model->vertices[3*i+2]);				
		}
		//write trangles:
		int t1,t2,t3;
		group = m_Model->groups;
		while (group)
		{	
			for (i = 0; i < group->numtriangles; i++) 
			{
				triangle = &m_Model->triangles[ (group->triangles[i]) ];
				t1=3*triangle->vindices[0]/3-1;
				t2=3*triangle->vindices[1]/3-1;
				t3=3*triangle->vindices[2]/3-1;
				fprintf(fp,"3 %d %d %d\n",t1,t2,t3);			
			}
			group = group->next;
		}
		///////////////////////////////////////////////////////
		fclose(fp);
		
		return TRUE;
	}
	return FALSE;
}

void CReadObj::GetVertex(float &x, float &y, float &z, int index)
{	
	
	ASSERT( (GLuint)index <= m_Model->numvertices);

	 x = m_Model->vertices[3*index];
	 y = m_Model->vertices[3*index + 1];
	 z = m_Model->vertices[3*index + 2];	
}

void CReadObj::GetTriangle(int &a, int &b, int &c, int index)
{
	ASSERT((GLuint)index < m_Model->numtriangles );

	a = m_TriangleIndexA[index];
	b = m_TriangleIndexB[index];
	c = m_TriangleIndexC[index];
}

int  CReadObj::GetVertexNum()
{
	return m_Model->numvertices;
}

int  CReadObj::GetTriangleNum()
{
	return m_Model->numtriangles;
}

